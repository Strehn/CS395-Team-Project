<!--
     Topological Sorting (DFS)
     Written by: Sam Spalding, Sydney Petrehn
     April 16 2020
-->

<!DOCTYPE html>
<html>
<head>
    <!-- This was given by DR. BC-->
    <meta http-equiv="X-UA-Compatible" content="IE=EDGE" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <!-- Chrome browser will display response in the form of html page by using above line. -->
    <!-- Here is where we can make our own "script" It is in Javascript-->
    <script type="text/javascript">
        //Create Stack Class and functions
        class Stack {

            //Stack class is contructed with an empty array
            constructor() {
                this.elements = [];
            }
        }

        //Function to pop an element from a stack and return the popped element
        Stack.prototype.pop = function () {

            return this.elements.pop();
        }

        //Function to push a given element onto the stack
        Stack.prototype.push = function (element) {

            this.elements.push(element);
        }

        //Function that returns the top element from the stack
        //Not used so far
        Stack.prototype.peek = function () {

            return this.elements[this.elements.length - 1];
        }

        //Function that returns the size of the stack
        Stack.prototype.size = function () {

            return this.elements.length;
        }

        //Function that prints the contents of the stack
        //Not used so far except for debugging
        Stack.prototype.printStack = function () {

            var str = "";

            for (var i = 0; i < this.elements.length; i++) {
                str += this.elements[i] + " ";
            }
            return str;
        }
        //Create Stack Class and function -- end


        //Create Graph class and functions
        class Graph {

            //Graph class is constructed with a given size of vertices and an adjacency list implemented as a map
            //a map object holds key-value pairs and remembers the insertion order of the keys
            //The key will be the vertices, and the values will be the vertex's adjacent vertices
            constructor(noOfVertices) {

                this.noOfVertices = noOfVertices;
                this.AdjList = new Map();
            }
        }

        //Function that adds a given vertex to the map object as a key
        Graph.prototype.addVertex = function (vertex) {

            this.AdjList.set(vertex, []);
        }

        //Function that connects two vertices with a directed edge
        Graph.prototype.addEdge = function (src, dest) {

            this.AdjList.get(src).push(dest); //gets the src vertex (the key) and pushes the dest vertex onto its value list in the map object, AdjList
        }

        //Function that prints the graph's adjacency matrix
        Graph.prototype.printGraph = function () {

            var get_keys = this.AdjList.keys(); //assigns get_keys the list of keys in the map object, AdjList. So get_keys is assigned the list of vertices used in the graph

            //for each vertex
            for (var i of get_keys) {

                var get_values = this.AdjList.get(i); //get the list of vertices adjacent to the current i vertex
                var conc = ""; //create an empty string

                //for each vertex adjacent to the current i vertex
                for (var j of get_values) {

                    conc += j + " "; //add that value to the string with a space
                }

                console.log(i + " -> " + conc); //Print the i vertex and its adjacent vertices
            }
        }

        //Function that does Topological Sorting by callling the recursive Topological Sorting Utility function
        Graph.prototype.topoSort = function () {

            let stack = new Stack(); //create a new stack instance

            //Create a visted array that tells whether or not a vertex has been visited yet
            //initialize each entry to be false
            let visited = new Array(arraySize);
            for (var i = 0; i < arraySize; i++) {
                visited[i] = false;
            }

            //For each vertex in the graph
            for (var i = 0; i < arraySize; i++) {

                //check to see if that vertex has been visitied yet
                if (visited[i] === false) {

                    graph.topoSortUtil(i, visited, stack); //if it hasn't been visited yet, call the Topological Sorting Utility function
                }
            }

            //Once it is done going through the vertices of the graph
            //The stack should have the vertices in opposite topological order
            //So we just need to pop them off and print them in the correct order

            //So long as there is something on the stack
            while (stack.size() !== 0) {

                //print the returned vertex being popped off the stack
                console.log(stack.pop());
            }
        }

        //Function that uses recursion to do topological sorting
        //inputs are:
        //the vertex currently being visited, the visited array, and the stack
        Graph.prototype.topoSortUtil = function (vertex, visited, stack) {

            visited[vertex] = true; //mark that the current vertex has been visited

            var adjVertices = this.AdjList.get(vertex); //create a variable that holds the value (list of adjacent vertices) of the given key (vertex) from the map object, AdjList

            //for every value in the list of adjacent vertices
            for (var i of adjVertices) {

                //Check if that adjacent vertices has already been visited
                if (!visited[i]) {

                    this.topoSortUtil(i, visited, stack); //if not, call the Topological Sort Utility to go visit that adjacent vertex
                }
            }

            stack.push(vertex); //push the current vertex onto the stack once it hits a dead end (in other words, had no more adjacent vertices to visit)
        }
        //Create Graph class and function -- end

        function ClearGraph() {

            var arraySize = 9;
            for (var i = 0; i < arraySize; i++) {

                var idNode = "Node" + i;
                var x = document.getElementById(idNode).style.visibility = "hidden";

                for (var j = i + 1; j < arraySize; j++) {

                    var idEdge = "Edge" + i + "_" + j;
                    var y = document.getElementById(idEdge).style.visibility = "hidden";
                }
            }

        }

        //Create an instance of a graph randomly
        function CreateGraph() {
            var arraySize = Math.floor(Math.random() * (10 - 4) + 4); //This will be user choice
            var graph = new Graph(arraySize);

            for (var i = 0; i < arraySize; i++) {

                graph.addVertex(i);
                console.log(i);
                var idNode = "Node" + i;
                var x = document.getElementById(idNode).style.visibility = "visible";

            }
            for (var i = 0; i < arraySize; i++) {

                for (var j = i + 1; j < arraySize; j++) {

                    if (Math.floor(Math.random() * 101) < 35) {

                        graph.addEdge(i, j);
                        var idEdge = "Edge" + i + "_" + j;
                        var y = document.getElementById(idEdge).style.visibility = "visible"; 
                    }
                }
            }

        //graph.printGraph();
        }

        //Create an instance of a graph randomly -- end

        //console.log("Topological Sort of Graph");
        //graph.topoSort()
;
    </script>

    <!--Used to position and display graph-->
    <style>
        .container {
            position: relative;
            width: 100%;
            max-width: 500px;
        }

            .container .nodes {
                position: relative;
                top: 0;
                left: 700px;
            }

            .container .edges {
                position: absolute;
                top: 0;
                left: 700px;
            }

            .container .button {
                position: absolute;
                background-color: #000;
                border: 2px solid #000;
                color: white;
                height: 40px;
                width: 40px;
                text-align: center;
                text-decoration: none;
                display: inline-block;
                font-size: 14px;
                margin: 4px 2px;
                transition-duration: 0.2s;
                cursor: pointer;
                border-radius: 50%;
            }

                .container .button:hover {
                    background-color: white;
                    color: #000000;
                }

                .container .button:focus {
                    background-color: white;
                    color: #000000;
                }

            .container .button0 {
                top: 54px;
                left: 897px;
            }

            .container .button1 {
                top: 114px;
                left: 794px;
            }

            .container .button2 {
                top: 74.5px;
                left: 1014.5px;
            }

            .container .button3 {
                top: 226.2px;
                left: 753.2px;
            }

            .container .button4 {
                top: 166px;
                left: 1092px;
            }

            .container .button5 {
                top: 338px;
                left: 795px;
            }

            .container .button6 {
                top: 285px;
                left: 1092px;
            }

            .container .button7 {
                top: 398px;
                left: 898px;
            }

            .container .button8 {
                top: 377px;
                left: 1016px;
            }
    </style>
    <!--Used to position and display graph .. end-->
</head>


<body onload="welcome()" data-gr-c-s-loaded="true">
    <!-- Create The Header -->
    <script>createHeader("Topological Sort (DFS)");</script>

    <!-- Text About the Topological Sort @ the top -->
    <p>
        This is the

        <!-- Makes the text a hyperlink -->
        <a target="\&quot;_blank\&quot;" href="\&quot;https://en.wikipedia.org/wiki/Topological_sorting;">Topological Sort </a>

        implemented using

        <!-- Makes the text a hyperlink -->
        <a target="\&quot;_blank\&quot;" href="\&quot;https://en.wikipedia.org/wiki/Topological_sorting;">Depth First Search. </a>

        A topological sort of a directed graph is a linear ordering of its vertices such that for every
        directed edge uv from vertex u to vertex v, u comes before v in the ordering. For instance, the vertices of the graph may
        represent tasks to be performed, and the edges may represent constraints that one task must be performed before another;
        in this application, a topological ordering is just a valid sequence for the tasks. A topological ordering is possible if
        and only if the graph has no directed cycles, that is, if it is a directed acyclic graph (DAG). Any DAG has at least one topological
        ordering, and algorithms are known for constructing a topological ordering of any DAG in linear time.

        <!-- Line Breaks -->
        <br />
        <br />
    </p>

    <table id="HeaderTableID" style="background-color: rgb(128, 128, 128); width: 100%;"></table>

    <script>//welcome();</script>

    <form>

        <!-- Button for how many elements in graph -->
        <label for="NumNodes">Enter the number of nodes:</label><br>
        <br />
        <input type="number" step="1" pattern="\d+" />

        <p> Once finished, click the "Generate Graph" button </p>
    </form>

    <!-- This is the "start button" and when clicked it gets the number of nodes then generates the graph -->
    <!--<input style="visibility:visible;" type="button" id="GraphSearch" value="Generate Graph" onclick="CreateGraph()" enabled="">-->
    <button onclick="ClearGraph(); CreateGraph()">Generate Graph</button>

    <br />
    <br />

    <!-- This keeps track of the guess the user makes on what node is added to the stack next-->
    <div id="guess" style="visibility:hidden;">
        <label for="guess">Next Node In Stack Guess:</label>
        <br>
        <input type="text" name="guess" id="nodeGuess">
        <br>
    </div>

    <br />

    <!-- Button for toggeling show hint  -->
    <input style="visibility:hidden;" type="button" id="showHint" value="Show Hint" onclick="showHints()" enabled>

    <!-- Button to reset the algorithm -->
    <input style="visibility:hidden;" type="button" id="ButtonReset" value="Reset" onclick="location.reload()" enabled>

    <!-- Button to show hint -->
    <input style="visibility:hidden;" type="button" id="ButtonShowMe" value="Hint" onclick="nextStep()" disabled>

    <input style="visibility:hidden;" type="button" id="ButtonYes" value="Yes" onclick="choseYes()" disabled>

    <input style="visibility:hidden;" type="button" id="ButtonNo" value="No" onclick="choseNo()" disabled>

    <!--Dispaly graph but it's initially hidden-->
    <div class="container">
        <img src="Graph Images/0_1.png" class="edges" id="Edge0_1" style="visibility:hidden" />
        <img src="Graph Images/0_2.png" class="edges" id="Edge0_2" style="visibility:hidden" />
        <img src="Graph Images/0_3.png" class="edges" id="Edge0_3" style="visibility:hidden" />
        <img src="Graph Images/0_4.png" class="edges" id="Edge0_4" style="visibility:hidden" />
        <img src="Graph Images/0_5.png" class="edges" id="Edge0_5" style="visibility:hidden" />
        <img src="Graph Images/0_6.png" class="edges" id="Edge0_6" style="visibility:hidden" />
        <img src="Graph Images/0_7.png" class="edges" id="Edge0_7" style="visibility:hidden" />
        <img src="Graph Images/0_8.png" class="edges" id="Edge0_8" style="visibility:hidden" />
        <img src="Graph Images/1_2.png" class="edges" id="Edge1_2" style="visibility:hidden" />
        <img src="Graph Images/1_3.png" class="edges" id="Edge1_3" style="visibility:hidden" />
        <img src="Graph Images/1_4.png" class="edges" id="Edge1_4" style="visibility:hidden" />
        <img src="Graph Images/1_5.png" class="edges" id="Edge1_5" style="visibility:hidden" />
        <img src="Graph Images/1_6.png" class="edges" id="Edge1_6" style="visibility:hidden" />
        <img src="Graph Images/1_7.png" class="edges" id="Edge1_7" style="visibility:hidden" />
        <img src="Graph Images/1_8.png" class="edges" id="Edge1_8" style="visibility:hidden" />
        <img src="Graph Images/2_3.png" class="edges" id="Edge2_3" style="visibility:hidden" />
        <img src="Graph Images/2_4.png" class="edges" id="Edge2_4" style="visibility:hidden" />
        <img src="Graph Images/2_5.png" class="edges" id="Edge2_5" style="visibility:hidden" />
        <img src="Graph Images/2_6.png" class="edges" id="Edge2_6" style="visibility:hidden" />
        <img src="Graph Images/2_7.png" class="edges" id="Edge2_7" style="visibility:hidden" />
        <img src="Graph Images/2_8.png" class="edges" id="Edge2_8" style="visibility:hidden" />
        <img src="Graph Images/3_4.png" class="edges" id="Edge3_4" style="visibility:hidden" />
        <img src="Graph Images/3_5.png" class="edges" id="Edge3_5" style="visibility:hidden" />
        <img src="Graph Images/3_6.png" class="edges" id="Edge3_6" style="visibility:hidden" />
        <img src="Graph Images/3_7.png" class="edges" id="Edge3_7" style="visibility:hidden" />
        <img src="Graph Images/3_8.png" class="edges" id="Edge3_8" style="visibility:hidden" />
        <img src="Graph Images/4_5.png" class="edges" id="Edge4_5" style="visibility:hidden" />
        <img src="Graph Images/4_6.png" class="edges" id="Edge4_6" style="visibility:hidden" />
        <img src="Graph Images/4_7.png" class="edges" id="Edge4_7" style="visibility:hidden" />
        <img src="Graph Images/4_8.png" class="edges" id="Edge4_8" style="visibility:hidden" />
        <img src="Graph Images/5_6.png" class="edges" id="Edge5_6" style="visibility:hidden" />
        <img src="Graph Images/5_7.png" class="edges" id="Edge5_7" style="visibility:hidden" />
        <img src="Graph Images/5_8.png" class="edges" id="Edge5_8" style="visibility:hidden" />
        <img src="Graph Images/6_7.png" class="edges" id="Edge6_7" style="visibility:hidden" />
        <img src="Graph Images/6_8.png" class="edges" id="Edge6_8" style="visibility:hidden" />
        <img src="Graph Images/7_8.png" class="edges" id="Edge7_8" style="visibility:hidden" />
        <button class="button button0" id="Node0" style="visibility:hidden">0</button>
        <button class="button button1" id="Node1" style="visibility:hidden">1</button>
        <button class="button button2" id="Node2" style="visibility:hidden">2</button>
        <button class="button button3" id="Node3" style="visibility:hidden">3</button>
        <button class="button button4" id="Node4" style="visibility:hidden">4</button>
        <button class="button button5" id="Node5" style="visibility:hidden">5</button>
        <button class="button button6" id="Node6" style="visibility:hidden">6</button>
        <button class="button button7" id="Node7" style="visibility:hidden">7</button>
        <button class="button button8" id="Node8" style="visibility:hidden">8</button>
    </div>
    <!--Display graph, but it's initially hidden .. end-->
</body>

</html>
