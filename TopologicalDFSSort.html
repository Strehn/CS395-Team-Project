<!--
     Topological Sorting (DFS)
     Written by: Sam Spalding, Sydney Petrehn
     April 16 2020
-->

<!DOCTYPE html>
<html>
<head>
    <!-- This was given by DR. BC-->
    <meta http-equiv="X-UA-Compatible" content="IE=EDGE" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <!-- Chrome browser will display response in the form of html page by using above line. -->
    <link rel="stylesheet" href="general.css">
    <script type="text/javascript" src="../general.js"></script>
    <script type="text/javascript" src="../tableFunctions.js"></script>
    <script type="text/javascript" src="../headerFunction.js"></script>
    <script type="text/javascript" src="../pseudocodeFunctions.js"></script>

    <!-- Here is where we can make our own "script" It is in Javascript-->
    <script type="text/javascript">
        // - VARIABLES -
        var currentState = 0;
        var numNodes = 0;

        // Function to get the number of nodes for the graph Use this as the 'Main'
        function getNodes() {
            numNodes = parseInt(document.getElementById("NumNodes").value);
            createTableWithWidth(myTableId, SString.length + 1, 3, 90);
            createGraph();
            createPseudoTable();
            showElement("showHint");
            showElement("ButtonReset");
            showElement("ButtonShowMe");
            showElement("ButtonYes");
            showElement("ButtonNo");
            createPseudocodeTable(myPseudocodeTableId);
            appendPseudocodeTable(myPseudocodeTableId, "\n the first pseudocode thing goes here", "Show Me");
            showElement("guess");
        }


        function getString() {

            Key = String(document.getElementById("key").value);
            SString = String(document.getElementById("sString").value);
            testUser();
            createTableWithWidth(myTableId, SString.length + 1, 3, 90);
            printSearch(0, 0, "white");

        }
        

        async function createSearch() {
            LocationMatches = ""
            LocationGuesses = String(document.getElementById("locationGuesses").value) + " ";
            var i = -1;
            hideElement("ButtonShowMeSolution");
            printSearchCheck(0, 0, "yellow", 0);
            createPseudocodeTable(myPseudocodeTableId);
            appendPseudocode(myPseudocodeTableId, "For needle position = 0 to length of haystack – length of needle.\n\tFor each letter in the needle");
            appendPseudocodeQuestion(myPseudocodeTableId, "\t\tIs this a match?", "Yes", "No");
        }

        async function createSearchSolution() {
            LocationMatches = ""
            LocationGuesses = String(document.getElementById("locationGuesses").value) + " ";
            var i = -1;
            printSearchCheck(0, 0, "yellow", 0);
            let bFSMres = await bFSM(i + 1);
            hideElement("ButtonShowMeSolution");
            appendPseudocode(myPseudocodeTableId, "String matches found at: " + LocationMatches);
            appendPseudocode(myPseudocodeTableId, "Press \"Reset\" to start over.");
        }


        async function bFSM(start) {
            var i, j;
            for (i = start; i <= (SString.length - Key.length); i++) {
                let delayres = await delay(1000);
                j = 0;
                while (j < Key.length && Key[j] == SString[i + j]) {
                    printSearchCheck(0, i, "green", j);
                    let delayres = await delay(1000);
                    j++;
                }
                if (j == Key.length) {
                    printSearch(0, i, "green");
                    LocationMatches += i + " ";
                    let delayres = await delay(1500);
                }
                else {
                    printSearchCheck(0, i, "red", j);
                }

            }
        }

        function choseNo() {
            bFSMStep(false);
        }

        function choseYes() {
            bFSMStep(true);
        }

        var curr = 0;

        async function bFSMStep(answer) {
            if (currentState <= (SString.length - Key.length)) {
                if (curr < Key.length && Key[curr] == SString[currentState + curr]) {
                    if (answer == true) {
                        printSearchCheck(0, currentState, "green", curr);
                        appendPseudocode(myPseudocodeTableId, "\t\tCorrect, it is a Match");
                    }
                    else {
                        printSearchCheck(0, currentState, "red", curr);
                        appendPseudocode(myPseudocodeTableId, "\t\tIncorrect, it is a Match");

                    }
                    curr++;
                    let delayres = await delay(1000);

                }
                else {
                    if (answer == false) {
                        printSearchCheck(0, currentState, "green", curr);
                        appendPseudocode(myPseudocodeTableId, "\t\tCorrect, it is not a Match");

                    }
                    else {
                        printSearchCheck(0, currentState, "red", curr);
                        appendPseudocode(myPseudocodeTableId, "\t\tIncorrect, it is not a Match");

                    }
                    curr = 0;
                    let delayres = await delay(1000);
                    currentState++;
                    appendPseudocode(myPseudocodeTableId, "\tposition = " + currentState);


                }



                if (curr == Key.length) {
                    printSearch(0, currentState, "green");
                    LocationMatches += currentState + " ";
                    appendPseudocode(myPseudocodeTableId, "\tLength of matches equals length of needle");
                    appendPseudocode(myPseudocodeTableId, "\tSolution found at position: " + currentState);
                    currentState++;
                    appendPseudocode(myPseudocodeTableId, "\tposition = " + currentState);
                    curr = 0;
                    let delayres = await delay(2000);


                }
                if (currentState <= (SString.length - Key.length)) {
                    printSearchCheck(0, currentState, "yellow", curr);
                    if (curr == 0) {
                        appendPseudocode(myPseudocodeTableId, "\tFor each letter in the needle");

                    }
                    appendPseudocode(myPseudocodeTableId, "\t\tIs this a match?");
                }
                else {
                    currentState = 0;
                    hideElement("ButtonYes");
                    hideElement("ButtonNo");
                    checkAnswers();
                }



            }

        }


        function checkAnswers() {

            if (LocationMatches.localeCompare(LocationGuesses) == 0) {
                appendPseudocode(myPseudocodeTableId, "String matches found at: " + LocationMatches);
                appendPseudocodeTable(myPseudocodeTableId, "Your match locations are correct, press \"Reset\" to start over. Press \"Solution\" to see the algorithm run again", "Retry");
                showElement("ButtonShowMeSolution", "Solution");
            }
            else {
                appendPseudocodeTable(myPseudocodeTableId, "Your match location. guesses are incorrect, change your location guesses and press \"Retry\" to try algorithm again. Press \"Solution\" to see the algorithm run again", "Retry");
                showElement("ButtonShowMeSolution", "Solution");
            }
        }

        async function delay(delayInms) {
            return new Promise(resolve => {
                setTimeout(() => {
                    resolve(2);
                }, delayInms);
            });
        }


        function printSearch(n, m, color) {
            setCell(myTableId, 0, 1, "String");
            setCell(myTableId, 0, 2, "Key");
            setCellColor(myTableId, 0, 1, "yellow");
            setCellColor(myTableId, 0, 2, "yellow");

            clearSearchTable();

            for (y = 0; y < SString.length; y++) {
                setCell(myTableId, y + 1 + n, 1, SString[y]);
                setCell(myTableId, y + 1 + n, 0, y);
                setCellBorder(myTableId, y + 1 + n, 1, "1px solid black");
            }
            for (y = 0; y < Key.length; y++) {
                setCell(myTableId, y + m + 1, 2, Key[y]);
                setCellBorder(myTableId, y + m + 1, 2, "1px solid black");
                setCellColor(myTableId, y + m + 1, 1, color);
                setCellColor(myTableId, y + m + 1, 2, color);
            }
        }

        function printSearchCheck(n, m, color, x) {
            setCell(myTableId, 0, 1, "String");
            setCell(myTableId, 0, 2, "Key");
            setCellColor(myTableId, 0, 1, "yellow");
            setCellColor(myTableId, 0, 2, "yellow");

            clearSearchTable();

            for (y = 0; y < SString.length; y++) {
                setCell(myTableId, y + 1 + n, 1, SString[y]);
                setCell(myTableId, y + 1 + n, 0, y);
                setCellBorder(myTableId, y + 1 + n, 1, "1px solid black");

            }
            for (y = 0; y < Key.length; y++) {
                setCell(myTableId, y + m + 1, 2, Key[y]);
                setCellBorder(myTableId, y + m + 1, 2, "1px solid black");
            }
            setCellColor(myTableId, x + m + 1, 1, color);
            setCellColor(myTableId, x + m + 1, 2, color);
        }

        function clearSearchTable() {

            for (y = 1; y <= SString.length; y++) {
                setCell(myTableId, y, 2, "");
                setCell(myTableId, y, 1, "");
                setCell(myTableId, y, 0, "");
                setCellBorder(myTableId, y, 2, "");
                setCellBorder(myTableId, y, 1, "");
                setCellBorder(myTableId, y, 0, "");
                setCellColor(myTableId, y, 2, "white");
                setCellColor(myTableId, y, 1, "white");
                setCellColor(myTableId, y, 0, "white");

            }
        }

        function welcome() {
            sayIt("A topological sort of a directed graph is a linear ordering of its verticies such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering. vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering.A topological ordering is possible if and only if the graph has no directed cycles, that is, if it is a directed acyclic graph(DAG).Any DAG has at least one topological ordering, and algorithms are known for constructing a topological ordering of any DAG in linear time.");

        }</script>
</head>


<body onload="welcome()" data-gr-c-s-loaded="true">
    <!-- Create The Header -->
    <script>
        createHeader("Topological Sort (DFS)");
    </script>

    <!-- Text About the Topological Sort @ the top -->
    <p>
        This is the

        <!-- Makes the text a hyperlink -->
        <a target="\&quot;_blank\&quot;" href="\&quot;https://en.wikipedia.org/wiki/Topological_sorting;">Topological Sort </a>

        implemented using

        <!-- Makes the text a hyperlink -->
        <a target="\&quot;_blank\&quot;" href="\&quot;https://en.wikipedia.org/wiki/Topological_sorting;">Depth First Search. </a>

        A topological sort of a directed graph is a linear ordering of its vertices such that for every
        directed edge uv from vertex u to vertex v, u comes before v in the ordering. For instance, the vertices of the graph may
        represent tasks to be performed, and the edges may represent constraints that one task must be performed before another;
        in this application, a topological ordering is just a valid sequence for the tasks. A topological ordering is possible if
        and only if the graph has no directed cycles, that is, if it is a directed acyclic graph (DAG). Any DAG has at least one topological
        ordering, and algorithms are known for constructing a topological ordering of any DAG in linear time.

        <!-- Line Breaks -->
        <br />
        <br />
    </p>

    <table id="HeaderTableID" style="background-color: rgb(128, 128, 128); width: 100%;"></table>

    <script>//welcome();</script>

    <form>

        <!-- Button for how many elements in graph -->
        <label for="NumNodes">Enter the number of nodes:</label><br>
        <br />
        <input type="number" step="1" pattern="\d+" />

        <p> Once finished, click the "Generate Graph" button </p>
    </form>

    <!-- This is the "start button" and when clicked it gets the number of nodes then generates the graph -->
    <input style="visibility:visible;" type="button" id="GraphSearch" value="Generate Graph" onclick="getNodes()" enabled="">

    <br />
    <br />
    <br />

    <!-- Button for toggeling show hint  -->
    <input style="visibility:hidden;" type="button" id="showHint" value="Show Hint" onclick="showHints()" enabled>

    <!-- Button to reset the algorithm -->
    <input style="visibility:hidden;" type="button" id="ButtonReset" value="Reset" onclick="location.reload()" enabled>

    <!-- Button to show hint -->
    <input style="visibility:hidden;" type="button" id="ButtonShowMe" value="Hint" onclick="nextStep()" disabled>


    <input style="visibility:hidden;" type="button" id="ButtonYes" value="Yes" onclick="choseYes()" disabled>

    <input style="visibility:hidden;" type="button" id="ButtonNo" value="No" onclick="choseNo()" disabled>

</body>

</html>
